import numpy as np
from scipy.spatial.transform import Rotation as R
# 第一组数据-27.5639494686671	-18.9033162869848	4.88896729004119	-5.41754788270904	-18.8496330620649	-25.3358765352652
# 第二组数据-12.4139488964626	17.9966842852198	-21.4890310620096	21.7324529279141	17.7503692267535	-13.4778761524842
# 第三组数据-30.4139498501369	7.94668409448489	-1.6450311993387	2.08245211729096	6.35036865454888	-31.8698763508485
# 原始数据（前三个数据）
# [-27.5639494686671, -18.9033162869848, 4.88896729004119],
# [-5.41754788270904,	-18.8496330620649,	-25.3358765352652],
source = np.array([
                   [-12.4139488964626, 17.9966842852198, -21.4890310620096],
                   [-30.4139498501369,	7.94668409448489,	-1.6450311993387]])

source=np.array([[6.87553180673294,	18.4711488722176,	-25.7850055700833],
                 [-19.3744696237785,	9.32114830001298,	-24.0910058027799]
                 ])
# 目标数据（后三个数据）
target = np.array([
                   [21.7324529279141, 17.7503692267535, -13.4778761524842],
                   [2.08245211729096,	6.35036865454888,	-31.8698763508485]])


# 计算旋转矩阵（使用SVD）
# 使用scipy中的Rotation类直接计算旋转矩阵
rotation = R.align_vectors(target, source)[0]
print(rotation)
# 旋转矩阵
rotation_matrix = rotation.as_matrix()
print("Rotation Matrix:\n", rotation_matrix)
# 对所有源向量应用旋转
test=[-30.863949659402,10.64668390375,-3.58103202331331]
test=[-15.1139489441463,	-24.0033185758032,	17.9569680834982]
test_3=[-20.8744696237785,	11.7211483953804,	-23.1230058676297]
test_3=[-22.2244700052483,	-18.5788541795402,	-16.3470058447416]

# test=[-30.863949659402,	8.09668371301516,	-2.37103103149202]
rotated_vectors = np.dot(test_3, rotation_matrix.T)  # 注意使用转置矩阵

print("Rotated Vectors:\n", rotated_vectors)

